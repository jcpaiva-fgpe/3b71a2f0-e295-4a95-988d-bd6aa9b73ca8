<p>As we said before, we can also use subqueries in clauses like <code>HAVING</code> or <code>FROM</code>.</p><p>Using a subquery in a <code> clause HAVING</code>, does not differ from the one already explained in the <code>WHERE</code> clause, so we will focus, in this section, on its use in the <code>FROM</code> clause.</ p><h2>Subcobsults in <code>FROM</code>.</h2><p>Remember that, in the <code>FROM</code> clause, we must refer to the tables that we are going to use in the query.</p><blockquote><p><code>...<br />FROM employees JOIN departments USING...</code></p></blockquote><p>In the example above < code>employees</code> and <code>departments</code> are tables of the <code>HR</code> schema.</p><p>Also note that the result of the <code>SELECT</ statements code> are displayed in table format, which makes them objects that can be referenced in the <code>FROM</code> clause, as long as we give them an <em>alias of ta blah</em>.</p><h3>Example:</h3><p>We are going to build a statement that shows the employees who have more seniority than the highest paid in their department.</p><p >Just as anyone who doesn't have a database would do, I would first look up who the highest paid in each department are and what their hire date is:</p><blockquote><p><code>SELECT FIRST_NAME , DEPARTMENT_ID, HIRE_DATE<br />FROM employees<br />WHERE (DEPARTMENT_ID, SALARY) IN (<br /> SELECT DEPARTMENT_ID, MAX(SALARY)<br /> FROM EMPLOYEES<br /> GROUP BY DEPARTMENT_ID<br /> )<br />ORDER BY DEPARTMENT_ID;</code></p></blockquote><p>The result would be <strong>a table</strong> like the following:</p><table align="center " border="1" summary="Results from query"><tbody><tr><th style="background-color:#9e9e9e; text-align:center">FIRST_NAME</th><th style="background-color:#9e9e9e; text-align:center">DEPARTMENT_ID</th><th style="background-color:#9e9e9e; text-align:center">HIRE_DATE</th></tr><tr><td>Jennifer</td><td>10</td><td>17-SEP-03</td></tr ><tr><td>Michael</td><td>20</td><td>17-FEB-04</td></tr><tr><td>Den</td><td> 30</td><td>07-DEC-02</td></tr><tr><td>...</td><td>...</td><td>... </td></tr></tbody></table><p>In later contents of the course, we will see that this table could even be saved in the database. For now, we are only going to give it an alias ( <code>BETTERPAID</code>), to be able to reference it.</p><p>Having this table, we can now search for employees with seniority greater than the <code>BETTERPAID</code> of their department: </p><blockquote><p><code>SELECT DISTINCT EMP.FIRST_NAME, EMP.LAST_NAME, EMP.DEPARTMENT_ID, EMP.HIRE_DATE<br />FROM EMPLOYEES EMP JOIN <strong>BETTERPAID</strong> ON (EMP. DEPARTMENT_ID = <strong>BETTERPAID</strong>.DEPARTMENT_ID)<br />WHERE EMP.HIRE_DATE <<strong>BETTERPAID</strong>.HIRE_DATE<br />ORDER BY EMP.DEPARTMENT_ID, EMP.LAST_NAME;</code> </p></blockquote><p>Already! or that if we execute the previous query, the result would be: <code>ERROR: relation "betterpaid" does not exist</code></p><p>The only thing left for us to do is put the query that we use to obtain the <code>BETTERPAID</code> table, as the subquery that defines said table:</p><blockquote><p><code>SELECT DISTINCT EMP.FIRST_NAME, EMP.LAST_NAME, EMP.DEPARTMENT_ID, EMP.HIRE_DATE <br />FROM EMPLOYEES EMP JOIN <strong>(<br /> SELECT FIRST_NAME, DEPARTMENT_ID, HIRE_DATE<br /> FROM employees<br /> WHERE (DEPARTMENT_ID, SALARY) IN (<br /> SELECT DEPARTMENT_ID, MAX(SALARY )<br /> FROM EMPLOYEES<br /> GROUP BY DEPARTMENT_ID<br /> )<br /> ORDER BY DEPARTMENT_ID<br />) BETTERPAID</strong> ON (EMP.DEPARTMENT_ID = BETTERPAID.DEPARTMENT_ID)<br /> WHERE EMP.HIRE_DATE < BETTERPAID.HIRE_DATE<br />ORDER BY EMP.DEPARTMENT_ID, EMP.LAST_NAME;</code></p></blockquote><p>Now the data we were looking for is obtained:</p> <table align="center" border="1" summary="Re sults from query"><tbody><tr><th style="background-color:#9e9e9e; text-align:center">FIRST_NAME</th><th style="background-color:#9e9e9e; text-align:center">LAST_NAME</th><th style="background-color:#9e9e9e; text-align:center">DEPARTMENT_ID</th><th style="background-color:#9e9e9e; text-align:center">HIRE_DATE</th></tr><tr><td>Sarah</td><td>Bell</td><td>50</td><td>04-FEB- 04</td></tr><tr><td>Alexis</td><td>Bull</td><td>50</td><td>20-FEB-05</td></ tr><tr><td>...</td><td>...</td><td>...</td><td>...</td></tr>< tr><td>David</td><td>Austin</td><td>60</td><td>25-JUN-05</td></tr><tr><td>Ellen< /td><td>Abel</td><td>80</td><td>11-MAY-04</td></tr><tr><td>Janette</td><td>King </td><td>80</td><td>30-JAN-04</td></tr><tr><td>...</td><td>...</td ><td>...</td><td>...</td></tr></tbody></table><p>The possibilities of nesting subqueries are endless (<em>or almost< /em>) and allow us to solve queries, gradually approaching the solution.</p><h3>Exercise:</h3><p>In the HR scheme there are employees whose salary coincides with the minimum established for the job they We are going to name the query corresponding to these employees as <em>MinimalPaid</em>.</p><p>Find out who are the heads of the departments in which these employees work in case they are asked a salary increase. Sort these department heads by their department name.</p>