<p>Como dissemos antes, também podemos usar subconsultas em cláusulas como <code>HAVING</code> ou <code>FROM</code>.</p><p>Usando uma subconsulta em uma cláusula <code> HAVING</code>, não difere do já explicado na cláusula <code>WHERE</code>, por isso vamos nos concentrar, nesta seção, em seu uso na cláusula <code>FROM</code>. </ p><h2>Subcobsults em <code>FROM</code>.</h2><p>Lembre-se que, na cláusula <code>FROM</code>, devemos nos referir às tabelas que vamos para usar na consulta.</p><blockquote><p><code>...<br />DE funcionários ENTRAR EM DEPARTAMENTOS USANDO...</code></p></blockquote><p>Em o exemplo acima < code>employees</code> e <code>departments</code> são tabelas do esquema <code>HR</code>.</p><p>Observe também que o resultado do <code As instruções >SELECT</ code> são exibidas em formato de tabela, o que os torna objetos que podem ser referenciados na cláusula <code>FROM</code>, desde que dermos a eles um <em>alias de ta blá</em>.</p><h3>Exemplo:</h3><p>Vamos construir uma declaração que mostre os funcionários que têm mais antiguidade do que o mais bem pago em seu departamento.</p>< p >Assim como qualquer pessoa que não tenha um banco de dados faria, eu primeiro procuraria quem são os mais bem pagos em cada departamento e qual é a data de contratação:</p><blockquote><p><code>SELECT FIRST_NAME , DEPARTMENT_ID, HIRE_DATE<br />DE funcionários<br />ONDE (DEPARTMENT_ID, SALARY) IN (<br /> SELECT DEPARTMENT_ID, MAX(SALARY)<br /> FROM EMPLOYEES<br /> GROUP BY DEPARTMENT_ID<br /> )<br />ORDER BY DEPARTMENT_ID;</code></p></blockquote><p>O resultado seria <strong>uma tabela</strong> como a seguinte:</p><table align=" center " border="1" summary="Resultados da consulta"><tbody><tr><th style="background-color:#9e9e9e; text-align:center">FIRST_NAME</th><th style="background-color:#9e9e9e; text-align:center">DEPARTMENT_ID</th><th style="background-color:#9e9e9e; text-align:center">HIRE_DATE</th></tr><tr><td>Jennifer</td><td>10</td><td>17-SEP-03</td></tr ><tr><td>Michael</td><td>20</td><td>17-FEV-04</td></tr><tr><td>Den</td><td> 30</td><td>07-DEZ-02</td></tr><tr><td>...</td><td>...</td><td>... </td></tr></tbody></table><p>Nos conteúdos posteriores do curso, veremos que essa tabela pode até ser salva no banco de dados. Por enquanto, vamos apenas dar-lhe um alias ( <code>BETTERPAID</code>), para poder referenciá-lo.</p><p>Tendo esta tabela, podemos agora pesquisar funcionários com antiguidade superior a <code>BETTERPAID</code> do departamento: </p><blockquote><p><code>SELECT DISTINCT EMP.FIRST_NAME, EMP.LAST_NAME, EMP.DEPARTMENT_ID, EMP.HIRE_DATE<br />FROM EMPLOYEES EMP JOIN <strong>BETTERPAID</strong> ON (EMP. DEPARTMENT_ID = <strong>BETTERPAID</strong>.DEPARTMENT_ID)<br />WHERE EMP.HIRE_DATE <<strong>BETTERPAID</strong>.HIRE_DATE<br />ORDER BY EMP.DEPARTMENT_ID, EMP.LAST_NAME; </code> </p></blockquote><p>Já! ou que se executarmos a consulta anterior, o resultado seria: <code>ERRO: relação "betterpaid" não existe</code></p><p>A única coisa que nos resta fazer é colocar a consulta que usamos para obter a tabela <code>BETTERPAID</code>, como a subconsulta que define essa tabela:</p><blockquote><p><code>SELECT DISTINCT EMP.FIRST_NAME, EMP.LAST_NAME, EMP.DEPARTMENT_ID, EMP.HIRE_DATE <br />FROM EMPLOYEES EMP JOIN <strong>(<br /> SELECT FIRST_NAME, DEPARTMENT_ID, HIRE_DATE<br /> FROM employees<br /> WHERE (DEPARTMENT_ID, SALARY) IN (<br /> SELECT DEPARTMENT_ID, MAX(SALÁRIO)<br /> DE EMPLOYEES<br /> GRUPO POR DEPARTMENT_ID<br /> )<br /> ORDEM POR DEPARTMENT_ID<br />) MELHOR PAGO</strong> ATIVADO (EMP.DEPARTMENT_ID = MELHOR PAGO.DEPARTMENT_ID)< br /> WHERE EMP.HIRE_DATE < BETTERPAID.HIRE_DATE<br />ORDER BY EMP.DEPARTMENT_ID, EMP.LAST_NAME;</code></p></blockquote><p>Agora os dados que estávamos procurando são obtidos: </p> <table align="center" border="1" summary="Re resultados da consulta"><tbody><tr><th style="background-color:#9e9e9e; text-align:center">FIRST_NAME</th><th style="background-color:#9e9e9e; text-align:center">LAST_NAME</th><th style="background-color:#9e9e9e; text-align:center">DEPARTMENT_ID</th><th style="background-color:#9e9e9e; text-align:center">HIRE_DATE</th></tr><tr><td>Sarah</td><td>Bell</td><td>50</td><td>04-FEB- 04</td></tr><tr><td>Alexis</td><td>Touro</td><td>50</td><td>20-FEV-05</td></ tr><tr><td>...</td><td>...</td><td>...</td><td>...</td></tr>< tr><td>David</td><td>Austin</td><td>60</td><td>25-JUN-05</td></tr><tr><td>Ellen< /td><td>Abel</td><td>80</td><td>11-MAY-04</td></tr><tr><td>Janete</td><td>Rei </td><td>80</td><td>30-JAN-04</td></tr><tr><td>...</td><td>...</td ><td>...</td><td>...</td></tr></tbody></table><p>As possibilidades de aninhar subconsultas são infinitas (<em>ou quase< /em>) e nos permitem solucionar dúvidas, aproximando-se gradativamente da solução.</p><h3>Exercício:</h3><p>No esquema de RH existem funcionários cujo salário coincide com o mínimo estabelecido para o cargo que exercem. Vamos nomear a consulta correspondente a esses funcionários como <em>MinimalPaid</em>.</p><p>Descubra quem são os chefes dos departamentos em que esses funcionários trabalham, caso sejam solicitados um aumento salarial. Classifique esses chefes de departamento pelo nome do departamento.</p>