<p>Como dijimos anteriormente, tambi&eacute;n podemos utilizar subconsultas en cl&aacute;usulas como <code>HAVING</code> o <code>FROM</code>.</p><p>La utilizaci&oacute;n de una subconsulta en una cl&aacute;sula <code>HAVING</code>, no difiere de la ya explicada en la cl&aacute;usula <code>WHERE</code>, por lo que nos centraremos, en este apartado a su utilizaci&oacute;n en la cl&aacute;sula <code>FROM</code>.</p><h2>Subcobsultas en <code>FROM</code>.</h2><p>Recordemos que, en la cl&aacute;sula <code>FROM</code>, debemos hacer referencia a las tablas que vamos a utilizar en la consulta.</p><blockquote><p><code>...<br />FROM employees JOIN departments USING...</code></p></blockquote><p>En el ejemplo anterior <code>employees</code> y <code>departments</code> son tablas del esquema <code>HR</code>.</p><p>Observemos tambi&eacute;n que el resultado de las sentencias <code>SELECT</code> se muestran en formato tabla, lo que las convierte en objetos que se pueden referenciar en la cl&aacute;usula <code>FROM</code>, siempre y cuando le asignemos un <em>alias de tabla</em>.</p><h3>Ejemplo:</h3><p>Vamos a construir una sentencia que muestre los empleados que tienen una antig&uuml;edad mayor que los mejor pagados de su departamento.</p><p>Igual que har&iacute;a cualquier persona que no dispusiera de una base de datos, buscar&iacute;a en primer lugar qui&eacute;nes son los mejor pagados de cada departamento y cu&aacute;l es su fecha de contrataci&oacute;n:</p><blockquote><p><code>SELECT FIRST_NAME, DEPARTMENT_ID, HIRE_DATE<br />FROM employees<br />WHERE (DEPARTMENT_ID, SALARY) IN (<br />&nbsp;&nbsp;&nbsp; SELECT DEPARTMENT_ID, MAX(SALARY)<br />&nbsp;&nbsp;&nbsp; FROM EMPLOYEES<br />&nbsp;&nbsp;&nbsp; GROUP BY DEPARTMENT_ID<br />)<br />ORDER BY DEPARTMENT_ID;</code></p></blockquote><p>El resultado ser&iacute;a <strong>una tabla</strong> como la siguiente:</p><table align="center" border="1" summary="Results from query"><tbody><tr><th style="background-color:#9e9e9e; text-align:center">FIRST_NAME</th><th style="background-color:#9e9e9e; text-align:center">DEPARTMENT_ID</th><th style="background-color:#9e9e9e; text-align:center">HIRE_DATE</th></tr><tr><td>Jennifer</td><td>10</td><td>17-SEP-03</td></tr><tr><td>Michael</td><td>20</td><td>17-FEB-04</td></tr><tr><td>Den</td><td>30</td><td>07-DEC-02</td></tr><tr><td>...</td><td>...</td><td>...</td></tr></tbody></table><p>En contenidos posteriores del curso, veremos que esta tabla la podr&iacute;amos incluso guardar en la base de datos. De momento, &uacute;nicamente le vamos a poner un alias (<code>BETTERPAID</code>), para poder referenciarla.</p><p>Disponiendo de esa tabla, ya podemos buscar a los empleados con una antig&uuml;edad mayor que los <code>BETTERPAID</code> de su departamento:</p><blockquote><p><code>SELECT DISTINCT EMP.FIRST_NAME, EMP.LAST_NAME, EMP.DEPARTMENT_ID, EMP.HIRE_DATE<br />FROM EMPLOYEES EMP JOIN&nbsp; <strong>BETTERPAID</strong> ON (EMP.DEPARTMENT_ID = <strong>BETTERPAID</strong>.DEPARTMENT_ID)<br />WHERE EMP.HIRE_DATE &lt; <strong>BETTERPAID</strong>.HIRE_DATE<br />ORDER BY EMP.DEPARTMENT_ID, EMP.LAST_NAME;</code></p></blockquote><p>Ya! ya! Es cierto que si ejecutamos la consulta anterior, el resultado ser&iacute;a: <code>ERROR:  relation "betterpaid" does not exist</code></p><p>Lo &uacute;nico que nos queda hacer es poner la consulta que utilizamos para obtener la tabla de los <code>BETTERPAID</code>, como la subconsulta que define dicha tabla:</p><blockquote><p><code>SELECT DISTINCT EMP.FIRST_NAME, EMP.LAST_NAME, EMP.DEPARTMENT_ID, EMP.HIRE_DATE<br />FROM EMPLOYEES EMP JOIN <strong>(<br />&nbsp;&nbsp;&nbsp; SELECT FIRST_NAME, DEPARTMENT_ID, HIRE_DATE<br />&nbsp;&nbsp;&nbsp; FROM employees<br />&nbsp;&nbsp;&nbsp; WHERE (DEPARTMENT_ID, SALARY) IN (<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT DEPARTMENT_ID, MAX(SALARY)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FROM EMPLOYEES<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GROUP BY DEPARTMENT_ID<br />&nbsp;&nbsp;&nbsp; )<br />&nbsp;&nbsp;&nbsp; ORDER BY DEPARTMENT_ID<br />) BETTERPAID</strong> ON (EMP.DEPARTMENT_ID = BETTERPAID.DEPARTMENT_ID)<br />WHERE EMP.HIRE_DATE &lt; BETTERPAID.HIRE_DATE<br />ORDER BY EMP.DEPARTMENT_ID, EMP.LAST_NAME;</code></p></blockquote><p>Ahora s&iacute; se obtienen los datos que busc&aacute;bamos:</p><table align="center" border="1" summary="Results from query"><tbody><tr><th style="background-color:#9e9e9e; text-align:center">FIRST_NAME</th><th style="background-color:#9e9e9e; text-align:center">LAST_NAME</th><th style="background-color:#9e9e9e; text-align:center">DEPARTMENT_ID</th><th style="background-color:#9e9e9e; text-align:center">HIRE_DATE</th></tr><tr><td>Sarah</td><td>Bell</td><td>50</td><td>04-FEB-04</td></tr><tr><td>Alexis</td><td>Bull</td><td>50</td><td>20-FEB-05</td></tr><tr><td>...</td><td>...</td><td>...</td><td>...</td></tr><tr><td>David</td><td>Austin</td><td>60</td><td>25-JUN-05</td></tr><tr><td>Ellen</td><td>Abel</td><td>80</td><td>11-MAY-04</td></tr><tr><td>Janette</td><td>King</td><td>80</td><td>30-JAN-04</td></tr><tr><td>...</td><td>...</td><td>...</td><td>...</td></tr></tbody></table><p>Las posibilidades de anidar subconsultas son infinitas (<em>o casi</em>) y nos permiten resolver consultas acerc&aacute;ndonos poco a poco a la soluci&oacute;n.</p><h3>Ejercicio:</h3><p>En el esquema HR aparecen empleados cuyo salario coincide con el m&iacute;nimo establecido para el trabajo que realizan. A la consulta correspondiente a estos empleados la vamos a nombrar como <em>MinimalPaid</em>.</p><p>Averigua qui&eacute;nes son los jefes de los departamentos en los que trabajan estos empleados por si se les solicitara un incremento salarial. Ordena a estos jefes de departamento seg&uacute;n el nombre de su departamento.</p>