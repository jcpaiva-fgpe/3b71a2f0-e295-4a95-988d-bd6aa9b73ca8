<p>La cl&aacute;usula <code>HAVING</code> permite establecer criterios sobre las filas resultantes tras la aplicaci&oacute;n de un <code>GROUP BY</code>.</p><h3>Sintaxis:</h3><p>La cl&aacute;usula <code>HAVING</code> la situaremos <code>inmediatamente despu&eacute;s del GROUP BY</code>, ya que sus criterios se aplicar&aacute;n sobre las filas generadas por el agrupamiento.</p><blockquote><p><code>SELECT columna1, columna2, ...<br />FROM tabla1, tabla2, ...<br />WHERE condici&oacute;n1, condici&oacute;n2, &hellip;<br /><strong>GROUP BY columna1, columna2, &hellip;<br />HAVING condici&oacute;n1, condici&oacute;n2, &hellip;</strong><br />ORDER BY ordenaci&oacute;n;</code></p></blockquote><p>Es muy importante entender que, a partir de este momento, tenemos 2 lugares en los que se pueden establecer criterios de selecci&oacute;n:</p><ul><li><code>WHERE</code>: sus criterios se eval&uacute;an antes de agrupar.</li><li><code>HAVING</code>: sus criterios se eval&uacute;an despu&eacute;s de agrupar.</li></ul><h3>Ejemplo:</h3><p>En un ejemplo anterior, vimos como mostrar el salario medio de todos los empleados por departamentos. En esta ocasi&oacute;n, en lugar de utilizar a todos los departamentos para calcular el salario medio, vamos a utilizar &uacute;nicamente a aquellos empleados cuyo trabajo contiene la palabra <em>CLERK</em>:</p><blockquote><p><code>SELECT DEPARTMENT_ID, ROUND(AVG(SALARY)) AS &quot;AVERAGE SALARY&quot;<br />FROM employees<br /><strong>WHERE JOB_ID LIKE &#39;%CLERK%&#39;</strong><br />GROUP BY DEPARTMENT_ID;</code></p></blockquote><table align="center" border="1" summary="Results from query"><tbody><tr><th style="background-color:#9e9e9e; text-align:center">DEPARTMENT_ID</th><th style="background-color:#9e9e9e; text-align:center">AVERAGE SALARY</th></tr><tr><td style="text-align:center">50</td><td>3000</td></tr><tr><td style="text-align:center">30</td><td>2780</td></tr></tbody></table><p>El criterio de que el trabajo de los empleados debe contener CLERK lo hemos tenido que poner en la cl&aacute;usula <code>WHERE</code>, ya que, como se puede observar, tras el agrupamiento, ya no disponemos del dato <code>JOB_ID</code>.</p><p>En la cl&aacute;usula HAVING, &uacute;nicamente podr&iacute;amos establecer criterios sobre los datos de los que dispongamos tras el agrupamiento, es decir, de los datos que aparecen en la tabla anterior. Por ejemplo, podr&iacute;amos querer que &uacute;nicamente se mostraran los departamentos en los que la media de los salarios de los empleados que realizan un trabajo que contiene CLERK fuera menor que 3000:</p><blockquote><p><code>SELECT DEPARTMENT_ID, ROUND(AVG(SALARY)) AS &quot;AVERAGE SALARY&quot;<br />FROM employees<br />WHERE JOB_ID LIKE &#39;%CLERK%&#39;<br />GROUP BY DEPARTMENT_ID<br /><strong>HAVING AVG(SALARY) &lt; 3000</strong>;</code></p></blockquote><table align="center" border="1" summary="Results from query"><tbody><tr><th style="background-color:#9e9e9e; text-align:center">DEPARTMENT_ID</th><th style="background-color:#9e9e9e; text-align:center">AVERAGE SALARY</th></tr><tr><td style="text-align:center">30</td><td>2780</td></tr></tbody></table><h3>Ejercicio:</h3><p>Muestra el salario <em>M&Iacute;NIMO</em> y <em>M&Aacute;XIMO</em> de los empleados de cada uno de los tipos de trabajo existentes.</p><p>Excluye del agrupamiento aquellos en los que el M&Iacute;NIMO y el M&Aacute;XIMO son iguales.</p><p>Ordena el resultado alfab&eacute;ticamente, en orden ASCENDENTE, seg&uacute;n el tipo de trabajo.</p>